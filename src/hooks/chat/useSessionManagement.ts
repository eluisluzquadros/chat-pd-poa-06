
// @ts-nocheck
import { useState, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { RefetchFunction } from "./types";
import { getCurrentAuthenticatedSession } from "@/utils/authUtils";
import { useQueryClient } from "@tanstack/react-query";
import { ChatSession } from "@/types/chat";

export function useSessionManagement(refetchSessions: RefetchFunction) {
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fun√ß√£o para validar UUID
  const isValidUUID = (str: string): boolean => {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(str);
  };

  const createSession = useCallback(async (userId: string, title: string, model: string, message: string, agentId?: string) => {
    const session = await getCurrentAuthenticatedSession();
    if (!session?.user) throw new Error("User not authenticated");
    
    // Criar sess√£o no chat_sessions
    // WORKAROUND: Remover agent_id temporariamente devido a cache do PostgREST
    const sessionData: any = {
      user_id: session.user.id,
      title: title.slice(0, 50),
      model,
      last_message: message,
    };
    
    // Tentar incluir agent_id se o cache permitir
    try {
      if (agentId) {
        sessionData.agent_id = agentId;
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è [createSession] Skipping agent_id due to cache issue');
    }
    
    const { data: newSession, error } = await supabase
      .from('chat_sessions')
      .insert(sessionData)
      .select()
      .single();

    if (error) throw error;

    // ‚úÖ OTIMIZADO: chat_sessions j√° cont√©m agent_id para rastreamento
    // N√£o precisamos mais de registro duplicado em conversations
    console.log('‚úÖ Sess√£o criada com rastreamento de agente:', { 
      sessionId: newSession.id, 
      agentId: agentId || 'null',
      userId: session.user.id 
    });

    setCurrentSessionId(newSession.id);
    return newSession.id;
  }, []);

  const deleteSession = useCallback(async (sessionId: string, showToast: boolean = true) => {
    try {
      console.log(`üîç [DELETE SESSION] Iniciando exclus√£o para: ${sessionId}`);
      console.log(`üîç [DELETE SESSION] Tipo: ${typeof sessionId}, Tamanho: ${sessionId.length}`);
      
      // Validar se o sessionId √© um UUID v√°lido
      if (!isValidUUID(sessionId)) {
        console.error(`‚ùå [DELETE SESSION] ID inv√°lido detectado: ${sessionId}`);
        
        // Remover diretamente do cache local se ID for inv√°lido
        const cachedSessions = queryClient.getQueryData(['chatSessions']) as ChatSession[] || [];
        const updatedSessions = cachedSessions.filter(session => session.id !== sessionId);
        queryClient.setQueryData(['chatSessions'], updatedSessions);
        
        // Limpar sess√£o atual se for a inv√°lida
        if (currentSessionId === sessionId) {
          setCurrentSessionId(null);
        }
        
        // For√ßar refetch para sincronizar com o banco
        await refetchSessions();
        
        if (showToast) {
          toast({
            title: "Sess√£o removida",
            description: "Sess√£o com ID inv√°lido foi removida da interface.",
            variant: "destructive"
          });
        }
        
        console.log(`‚úÖ [DELETE SESSION] ID inv√°lido removido do cache: ${sessionId}`);
        return;
      }

      console.log(`‚úÖ [DELETE SESSION] UUID v√°lido, prosseguindo com exclus√£o no banco`);
      
      // Use the new atomic SQL function for reliable deletion
      const { data, error } = await supabase.rpc('delete_chat_session_atomic', {
        session_id_param: sessionId
      });

      if (error) {
        console.error(`‚ùå [DELETE SESSION] RPC Error:`, error);
        throw error;
      }

      if (!data?.success) {
        console.error(`‚ùå [DELETE SESSION] Function returned error:`, data);
        throw new Error(data?.error || 'Falha na dele√ß√£o da conversa');
      }

      console.log(`‚úÖ [DELETE SESSION] Success:`, data);
      
      // Clear current session if it was deleted
      if (currentSessionId === sessionId) {
        setCurrentSessionId(null);
      }

      // For√ßar invalida√ß√£o completa das queries para garantir atualiza√ß√£o
      queryClient.invalidateQueries(['chatSessions']);
      
      // For√ßar refetch para garantir sincroniza√ß√£o
      await refetchSessions();
      console.log('üîÑ Cache invalidado e sess√µes recarregadas ap√≥s exclus√£o');

      if (showToast) {
        toast({
          title: "Sucesso",
          description: data.message || "Conversa exclu√≠da com sucesso",
        });
      }
    } catch (error: any) {
      console.error(`‚ùå [DELETE SESSION] Complete error details:`, {
        sessionId,
        error: error?.message || error,
        stack: error?.stack
      });
      
      if (showToast) {
        toast({
          title: "Erro",
          description: error?.message || "Falha ao excluir conversa",
          variant: "destructive",
        });
      }
      throw error;
    }
  }, [toast, currentSessionId, queryClient, refetchSessions]);

  const deleteSessions = useCallback(async (sessionIds: string[]) => {
    console.log(`üîç [DELETE SESSIONS] Iniciando exclus√£o em lote para ${sessionIds.length} sess√µes:`, sessionIds);
    
    // Separar IDs v√°lidos dos inv√°lidos
    const validIds: string[] = [];
    const invalidIds: string[] = [];
    
    sessionIds.forEach(id => {
      console.log(`üîç [DELETE SESSIONS] Verificando ID: ${id} (tipo: ${typeof id}, tamanho: ${id.length})`);
      if (isValidUUID(id)) {
        validIds.push(id);
        console.log(`‚úÖ [DELETE SESSIONS] ID v√°lido: ${id}`);
      } else {
        invalidIds.push(id);
        console.error(`‚ùå [DELETE SESSIONS] ID inv√°lido: ${id}`);
      }
    });
    
    // Limpar IDs inv√°lidos do cache imediatamente
    if (invalidIds.length > 0) {
      console.log(`üßπ [DELETE SESSIONS] Limpando ${invalidIds.length} IDs inv√°lidos do cache:`, invalidIds);
      const cachedSessions = queryClient.getQueryData(['chatSessions']) as ChatSession[] || [];
      const cleanedSessions = cachedSessions.filter(session => !invalidIds.includes(session.id));
      queryClient.setQueryData(['chatSessions'], cleanedSessions);
      
      // Limpar sess√£o atual se for inv√°lida
      if (currentSessionId && invalidIds.includes(currentSessionId)) {
        setCurrentSessionId(null);
        console.log(`üßπ [DELETE SESSIONS] Sess√£o atual inv√°lida removida: ${currentSessionId}`);
      }
    }
    
    const failedDeletions: string[] = [];
    const successResults: any[] = [];
    
    // Processar apenas IDs v√°lidos
    if (validIds.length > 0) {
      console.log(`‚úÖ [DELETE SESSIONS] Processando ${validIds.length} IDs v√°lidos:`, validIds);
      
      const deletePromises = validIds.map(async (sessionId) => {
        try {
          const { data, error } = await supabase.rpc('delete_chat_session_atomic', {
            session_id_param: sessionId
          });

          if (error) {
            console.error(`‚ùå [DELETE SESSIONS] RPC Error for ${sessionId}:`, error);
            failedDeletions.push(sessionId);
            return { sessionId, success: false, error };
          }

          if (!data?.success) {
            console.error(`‚ùå [DELETE SESSIONS] Function error for ${sessionId}:`, data);
            failedDeletions.push(sessionId);
            return { sessionId, success: false, error: data?.error };
          }

          successResults.push(data);
          console.log(`‚úÖ [DELETE SESSIONS] Sucesso para ${sessionId}`);
          return { sessionId, success: true, data };
        } catch (error) {
          console.error(`‚ùå [DELETE SESSIONS] Exception for ${sessionId}:`, error);
          failedDeletions.push(sessionId);
          return { sessionId, success: false, error };
        }
      });

      await Promise.all(deletePromises);
    }

    // For√ßar invalida√ß√£o completa e refetch
    const successfulIds = validIds.filter(id => !failedDeletions.includes(id));
    const totalCleaned = successfulIds.length + invalidIds.length;
    
    if (totalCleaned > 0) {
      // Clear current session if it was among the deleted ones
      if (currentSessionId && (successfulIds.includes(currentSessionId) || invalidIds.includes(currentSessionId))) {
        setCurrentSessionId(null);
      }

      // For√ßar invalida√ß√£o completa das queries
      queryClient.invalidateQueries(['chatSessions']);
      
      // For√ßar refetch para garantir sincroniza√ß√£o
      await refetchSessions();
      console.log('üîÑ Cache invalidado e sess√µes recarregadas ap√≥s exclus√£o m√∫ltipla');
    }

    // Show consolidated toast
    console.log(`üìä [DELETE SESSIONS] Resultados: ${successfulIds.length} v√°lidos exclu√≠dos, ${invalidIds.length} inv√°lidos removidos, ${failedDeletions.length} falharam`);
    
    if (failedDeletions.length === 0 && invalidIds.length === 0) {
      toast({
        title: "Sucesso",
        description: `${sessionIds.length} conversa(s) exclu√≠da(s) com sucesso`,
      });
    } else if (totalCleaned > 0) {
      let description = `${totalCleaned} conversa(s) removida(s).`;
      if (invalidIds.length > 0) {
        description += ` ${invalidIds.length} tinha(m) ID inv√°lido.`;
      }
      if (failedDeletions.length > 0) {
        description += ` ${failedDeletions.length} falharam.`;
      }
      
      toast({
        title: "Exclus√£o conclu√≠da",
        description,
        variant: invalidIds.length > 0 ? "destructive" : "default"
      });
    } else {
      toast({
        title: "Erro",
        description: "N√£o foi poss√≠vel excluir nenhuma conversa",
        variant: "destructive",
      });
    }

    if (failedDeletions.length > 0) {
      throw new Error(`Failed to delete ${failedDeletions.length} sessions: ${failedDeletions.join(', ')}`);
    }
  }, [toast, currentSessionId, queryClient, refetchSessions]);

  const updateSession = useCallback(async (sessionId: string, lastMessage: string) => {
    try {
      // Atualizar chat_sessions
      await supabase
        .from('chat_sessions')
        .update({ 
          last_message: lastMessage,
          updated_at: new Date().toISOString()
        })
        .eq('id', sessionId);

      // Remover incremento duplicado - agora feito diretamente no useMessageSubmit

      await refetchSessions();
    } catch (error) {
      console.error('Error updating session:', error);
      throw error;
    }
  }, [refetchSessions]);

  return {
    currentSessionId,
    setCurrentSessionId,
    createSession,
    deleteSession,
    deleteSessions,
    updateSession,
  };
}
